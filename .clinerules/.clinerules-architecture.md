# System Patterns: Syndicated Loan Management System

## 1. Architecture Overview

### 1.1 Layer Architecture (Lightweight DDD / 3-Tier)

本システムは、実用的な3層アーキテクチャ（Controller-Service-Repository）を基本とし、必要に応じてドメイン層の分離や拡張が可能な「軽量級DDD」構造を採用します。

- **Entity/Domain**: JPAエンティティ兼ドメインエンティティ（@Entity, @Table, @Id など）
- **Repository**: Spring Data JPAインターフェース
- **Service**: 業務ロジックを担うサービスクラス（@Service, @Transactional）
- **Controller**: REST APIエンドポイント（@RestController）
- **DTO**: APIリクエスト/レスポンス用DTO

#### パッケージ構成例

```
com.example.syndicatelending/
├── common/         # 共通値オブジェクト・例外
├── party/          # 参加者（Company, Borrower, Investor）
│   ├── entity/
│   ├── repository/
│   ├── service/
│   ├── controller/
│   └── dto/
├── syndicate/      # シンジケート団
│   ├── entity/
│   ├── repository/
│   ├── service/
│   ├── controller/
│   └── dto/
├── position/       # ポジション（Facility, Loan, SharePie等のドメインモデル）
│   ├── domain/     # ドメインモデル（JPA非依存の純粋な業務ロジック）
├── facility/       # 融資枠
│   ├── entity/
│   ├── repository/
│   ├── service/
│   ├── controller/
│   └── dto/
├── loan/           # 貸付・返済
│   ├── entity/
│   ├── repository/
│   ├── service/
│   ├── controller/
│   └── dto/
└── ...
```

- 各Bounded Contextごとに entity/repository/service/controller/dto を持つシンプルな構成
- position/domainは、FacilityやLoanなど複数コンテキストで共通利用される「純粋なドメインモデル（POJO）」を集約する役割。JPA非依存で業務ロジックや値オブジェクトを表現する。
- 必要に応じて、将来的にdomain.modelやdomain.service等の分離も可能

---

## 2. Design Patterns

- DDDの原則は意識しつつも、現状は「軽量級DDD」構造（3層＋DTO）を基本とする
- ドメインの複雑化や業務要件の高度化に応じて、段階的に重量級DDD構造へ発展可能

1.  **Entities:**
    *   Represent mutable concepts with a distinct identity (e.g., `Facility`, `Drawdown`).
    *   Encapsulate business logic and state related to the entity.
    *   Identified by a **Business ID** (e.g., UUID) in the Domain Layer, distinct from the JPA-managed auto-generated ID.
2.  **Value Objects (VOs):**
    *   Represent descriptive aspects of the domain with no conceptual identity (e.g., `Money`, `Percentage`, `FacilityId`, `TransactionId`).
    *   Immutable, treated as values.
    *   Encapsulate related data and domain logic specific to the value (e.g., `Money.add()`, `Percentage.applyTo(Money)`).
3.  **Aggregates:**
    *   A cluster of Entities and Value Objects treated as a single unit for data changes. An Aggregate Root is the primary entity reference point (e.g., `Facility`, `Drawdown` might be Aggregate Roots).
    *   Ensures data consistency within the boundary in a single transaction.
4.  **Repositories:**
    *   Provide an abstraction layer for accessing Aggregates.
    *   **Domain Repository Interfaces** (`domain.repository`): Defined in the Domain Layer, specifying *what* can be retrieved/saved (e.g., `findById(FacilityId)`, `save(Facility)`). Operate purely on Domain Entities.
    *   **Infrastructure Repository Implementations** (`infrastructure.persistence`): Implement the Domain Repository Interfaces using specific technologies (e.g., Spring Data JPA). Handle the mapping between Domain Entities and JPA Entities and interact with the database.

### 2.2 Application Service Pattern

Application Services represent the use cases or commands of the application.

1.  **Application Services (`application.service`):**
    *   Orchestrate interactions between Domain objects and Repositories.
    *   Implement specific business workflows (use cases) (e.g., `ProcessDrawdownService`).
    *   Manage transaction boundaries (`@Transactional`).
    *   Depend on Domain Repository Interfaces and Domain Services.
    *   Do **not** contain core business logic that belongs in the Domain layer.

### 2.3 Controller Pattern

Controllers act as the entry point from the outside world (e.g., REST API).

1.  **Feature-based Controllers (`infrastructure.api`):**
    *   Group related API endpoints for a specific feature.
    *   Handle HTTP requests and responses.
    *   Map Request DTOs to Application Service Command DTOs.
    *   Call the appropriate Application Service.
    *   Map Application Service Result DTOs to Response DTOs.
    *   Are kept thin; they delegate business logic execution entirely to Application Services.

## 3. Key Technical Decisions

### 3.1 Error Handling

*   **Layered Exceptions:** Domain layer throws Domain-specific exceptions (e.g., `InsufficientFundsException`). Application layer catches Domain exceptions and throws Application-specific exceptions (`ResourceNotFoundException`, `BusinessRuleViolationException`) that are meaningful at the application level.
*   **Global Exception Handler (`common.infrastructure.api.GlobalExceptionHandler`):** A `@RestControllerAdvice` component that catches Application exceptions (and standard framework exceptions like validation errors) and maps them to appropriate HTTP status codes and structured error responses.
*   **Structured Error Responses:** APIs return consistent JSON format for errors including status, error type, and a message.

### 3.2 Persistence (JPA)

*   **Separation of Domain Entities and JPA Entities:** Domain entities (`domain.model`) are pure Java objects without JPA annotations. JPA entities (`infrastructure.persistence.entity`) are defined in the Infrastructure layer, optimized for database mapping, and contain `@Entity`, `@Table`, `@Id`, `@GeneratedValue` etc.
*   **Auto-generated IDs:** Database-generated primary keys (e.g., `Long` with `IDENTITY` strategy) are used for JPA entities. Domain entities are identified by **Business IDs** (e.g., `UUID` Value Objects) which are distinct from the JPA primary key and are also persisted. Mappers handle the translation.
*   **Repository Implementation:** Infrastructure-level Repository implementations translate between Domain Entities and JPA Entities using Mappers and utilize Spring Data JPA interfaces (`JpaRepository`) for database interaction.

### 3.3 Testing

*   **Layered Testing Strategy:**
    *   **Domain Unit Tests:** Focus on Domain Entities, Value Objects, and Domain Services (`domain.model`, `domain.service`). Pure Java, no dependencies, very fast. Verify core business rules and calculations.
    *   **Application Service Tests:** Focus on Application Services (`application.service`). Use mocks for Repository *interfaces* and external services to test the business workflow orchestration independent of Infrastructure details. Verify use case execution flow and error handling.
    *   **Infrastructure Integration Tests:** Focus on Persistence (`infrastructure.persistence`) and API (`infrastructure.api`) layers. Test mapping between Domain/Application concepts and external technologies (DB, API). These tests are slower and require a running database/API endpoint.
*   **Repository Mocking:** Essential for fast and isolated Application Service tests. We mock the Domain Repository *interfaces* in Application Service tests.

## 4. EventSourcingについての検討と判断

本システムでは、FacilityやLoan（Transaction）など履歴や状態遷移が本質的な価値となる集約についてはEventSourcingの採用を検討しました。しかし、現時点でのSyndicateコンテキストは主に静的な構成情報（団体名、リードバンク、メンバー投資家リスト等）を管理するものであり、状態遷移や履歴管理の複雑さが少ないため、実利を重んじてEventSourcingは見送り、通常のエンティティ永続化方式を採用しています。

今後、FacilityやLoanなどで履歴管理や監査要件が高まった場合には、段階的にEventSourcingの導入を再検討します。

## 5. Data Model (Conceptual)

Based on the identified core entities and relationships:

```mermaid
erDiagram
    Borrower ||--o{ Facility : takes_out
    Investor ||--o{ FacilityInvestment : makes
    Facility ||--o{ FacilityInvestment : consists_of
    Facility ||--o{ Loan : derived_from
    Facility ||--o{ SharePie : defines_shares_for
    Investor ||--o{ SharePieComponent : part_of
    SharePie ||--o{ SharePieComponent : has
    Transaction ||--o{ Facility : related_to
    Transaction ||--o{ Loan : related_to
    Transaction ||--o{ AmountPie : defines_amounts_for
    Investor ||--o{ AmountPieComponent : part_of
    AmountPie ||--o{ AmountPieComponent : has
    Drawdown ||--|{ Transaction : is_a
    Payment ||--|{ Transaction : is_a
    FacilityTrade ||--|{ Transaction : is_a
    PrincipalPayment ||--|{ Payment : is_a
    InterestPayment ||--|{ Payment : is_a
    FeePayment ||--|{ Payment : is_a
    Syndicate ||--o{ Facility : manages
    Syndicate ||--o{ Investor : has_member
```
*(Note: This is a conceptual ER diagram based on the domain concepts. The actual JPA entity relationships might differ slightly due to mapping concerns like inheritance or embedded objects.)*

## 6. Transaction Patterns

Complex transaction processing is a core part of this system, handled by the `transaction` Bounded Context.

1.  **Payment Processing (Interest, Principal, Fee):**
    *   Involves calculation based on `Loan` balance, interest rates, fee types, and dates.
    *   Distribution of the received payment amount to individual investors based on the `Share Pie`, resulting in an `Amount Pie`.
    *   Updating `Loan` balance (for Principal Payments).
    *   Recording the specific `Payment` transaction (`InterestPayment`, `PrincipalPayment`, `FeePayment`).
    *   Domain Services (`FundDistributionService`) handle the complex calculation and distribution logic.
2.  **Trade Settlement (Facility Trade):**
    *   Involves the transfer of a portion of a `Facility` (and potentially associated `Loan`) from a selling investor to a buying investor.
    *   Requires updating the `Share Pie` of the affected `Facility` (and `Loan`).
    *   Recording the `Facility Trade` transaction.
    *   May involve settlement of funds between the selling and buying investors.

## 7. Integration Patterns

### 7.1 REST APIs

*   Provided by the `infrastructure.api` layer within each feature package.
*   Follow RESTful principles with resource-based endpoints (`/api/v1/facilities`, `/api/v1/drawdowns` etc.) and standard HTTP methods.
*   Utilize Request/Response DTOs (`infrastructure.api.dto`) for defining the external API contract.
*   Global Exception Handler ensures consistent error response formats and appropriate HTTP status codes.

### 7.2 Data Transfer (DTOs)

*   **API DTOs** (`infrastructure.api.dto`): Used exclusively at the API boundary for serialization/deserialization of external requests/responses.
*   **Application DTOs** (`application.dto`): Used within the Application layer as input (Command DTOs) and output (Result DTOs) for Application Services. These bridge the gap between the API format and the data needed/returned by the Application layer.
*   **Mappers:** Infrastructure layer is responsible for mapping between API DTOs, Application DTOs, and Domain objects.
*   **Validation:** Bean Validation (`@Valid`) is applied to API Request DTOs. Deeper business validation happens within the Application or Domain layers.
