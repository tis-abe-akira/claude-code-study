# progress

**ステップ 0: 共通モジュールと基本的なValue Objectの定義** ✅ 完了

*   実装済み: `Money`, `Percentage` Value Objects
*   実装済み: `ResourceNotFoundException`, `BusinessRuleViolationException` 例外クラス
*   実装済み: `GlobalExceptionHandler` による統一的エラー処理

*   **理由:** これらは様々なドメインやユースケースで必要となる基本的な構成要素だからです。早めに定義することで、後の開発がスムーズになります。

**ステップ 1: 主要な参加者 (`Party`) の登録・参照機能** ✅ 完了（簡素化版）

*   実装済み: `Company`, `Borrower`, `Investor` JPA Entity（ドメインエンティティ兼用）
*   実装済み: Spring Data JPA Repository インターフェース（`CompanyRepository`, `BorrowerRepository`, `InvestorRepository`）
*   実装済み: 統合サービス `PartyService`（企業・借り手・投資家の作成・検索・一覧機能）
*   実装済み: 統合コントローラー `PartyController`（REST API）
*   実装済み: Request DTO（`CreateCompanyRequest`, `CreateBorrowerRequest`, `CreateInvestorRequest`）
*   実装済み: 包括的テストスイート（Entity・Service・API統合テスト、全23テスト成功）
*   実装済み: バリデーション、例外処理、関連整合性チェック

**アーキテクチャ変更**: 複雑なDDD構造から実用的な3層アーキテクチャ（Controller-Service-Repository）に簡素化。
- クラス数を40個→13個に75%削減
- 理解しやすさとメンテナンス性を優先
- 必要に応じて後から複雑化可能な設計

*   **理由:** BorrowerやInvestorは、FacilityやTransactionなど、他の多くのドメイン概念と関連します。CRUD中心の機能では簡素化されたアーキテクチャが効率的であることを実証しました。

**ステップ 2: Facility の組成・参照機能**

*   `loanandfacility` Bounded Context の開発（`Facility` に焦点を当てる）。
*   `Facility`, `SharePie` のドメインモデル (`domain.model`) 定義。`Facility` が `Borrower` や `Investor` (または `Company`) を参照する形で関連付けを定義。
*   `FacilityRepository` インターフェース (`domain.repository`) 定義。
*   Facility を作成（組成）するApplication Service（例: `CreateFacilityService`）と、参照するApplication Service（例: `GetFacilityDetailsService`）。組成機能では、`SharePie` の情報も入力として受け取り、`Facility` オブジェクトを生成・永続化します。
*   対応するPersistence層 (`infrastructure.persistence`) のJPA Entity、Repository実装、Mapper。`SharePie` の永続化方法（例: JSONカラム、別の関連エンティティ）も検討・実装します。
*   対応するAPI層 (`infrastructure.api`) のController、Request/Response DTO。
*   これらの各層のテストコード。

*   **理由:** Facilityはシンジケートローンの基本的な「枠」を定義する重要な概念です。これができて初めて、ドローダウンなどのトランザクション処理が可能になります。ここでも、比較的シンプルな作成・参照機能から始めることで、複雑なドメインモデルの定義と永続化に慣れていきます。

**ステップ 3: 最も頻繁または重要なトランザクション処理（例: ドローダウン）**

*   `transaction` Bounded Context の開発（`Drawdown` に焦点を当てる）。
*   `Transaction`, `Drawdown`, `AmountPie` のドメインモデル (`domain.model`) 定義。`Drawdown` が `Facility` や `Borrower` を参照する形で関連付けを定義。
*   `TransactionRepository` インターフェース (`domain.repository`) 定義。
*   資金分配のDomain Service (`transaction.domain.service.FundDistributionService`) の定義と実装。
*   ドローダウンを実行するApplication Service (`transaction.application.service.ProcessDrawdownService`) の実装（前回のコード例）。このサービスは、`FacilityRepository` から `Facility` をロードし、その `applyDrawdown` メソッドを呼び出し、`FundDistributionService` を使って `AmountPie` を計算し、`TransactionRepository` を使って `Drawdown` を保存します。
*   対応するPersistence層 (`infrastructure.persistence`) のJPA Entity、Repository実装、Mapper。Transactionの継承マッピング戦略やAmountPieの永続化方法を具体的に実装します。
*   対応するAPI層 (`infrastructure.api`) のController、Request/Response DTO。
*   これらの各層のテストコード。特にApplication Serviceのテストは、異なるシナリオ（成功、資金不足、FacilityNotFoundなど）をカバーするように手厚く書きます。

*   **理由:** ドローダウンはシンジケートローンにおける中核的な資金移動トランザクションであり、複数のドメイン概念（Facility, SharePie, Transaction, AmountPie）と、Domain Service、Application Service を連携させる複雑なロジックを含みます。この最も重要な機能の実装とテストにここで集中的に取り組むことで、アーキテクチャの有効性を強く実感でき、複雑な業務ロジックの実装パターンを確立できます。

**ステップ 4 以降: その他のトランザクション処理や機能**

*   残りのトランザクション処理（Interest Payment, Principal Payment, Fee Payment, Facility Tradeなど）を、一つずつ開発します。それぞれのトランザクションタイプに対応するDomain Model、Domain Service、Application Service、Persistence実装、APIが必要になります。
*   Fee Payment の種類（コミットメントフィー、アレンジメントフィーなど）に応じて、計算ロジックや発生契機が異なるため、これはさらに複雑な機能セットになる可能性があります。
*   Syndicate 団の管理機能（Syndicate Bounded Context）など、まだ開発していないBounded Context の機能を実装します。

**開発順序を決める上での考慮事項:**

*   **フィードバックループ:** 可能であれば、ユーザーや業務担当者にとって最も早く触ってもらいたい、または早期にフィードバックが欲しい機能から始めることを検討してください。ドローダウンはコア機能なので、早い段階でフィードバックを得ることが重要かもしれません。
*   **チームの習熟度:** 新しいアーキテクチャやDDDに慣れていないチームであれば、ステップ1や2のような比較的シンプルな機能から始めることで、段階的に学習できます。
*   **技術的な不確実性:** もし、例えばSharePieやAmountPieの永続化方法に技術的な不確実性がある場合、ステップ2や3でその部分に早期に取り組んで技術的な検証を行うことも考えられます。
